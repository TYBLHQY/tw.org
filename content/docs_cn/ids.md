---
title: "Taskwarrior - 编号"
---

# 编号

Taskwarrior 将当前任务（主要是待处理和循环任务）保持在"工作集"中，并为它们分配 ID 号。
ID 号是工作集中任务的索引（从 1 开始）。
当任务完成或删除时，它会被移出工作集，并失去 ID。
所有任务，无论是否在工作集中，都有 UUID，并且始终可以通过 UUID 寻址。

通过拥有工作集，平均性能得到改善。
这有效，因为大多数命令和报告仅基于工作集中的待处理任务。
无论你完成多少工作，工作集往往在恒定大小下稳定[1]。
另一方面，任务的总数增长无限。
这意味着某些报告，如 `completed` 或 `all` 报告会随着时间推移而运行变慢，因为有更多数据需要读取和显示。

这种机制的一个很好的副作用是待处理任务的 ID 号保持较小，在数据输入期间不容易出错。

一个缺点是 ID 号偶尔会改变，尽管以可预测的方式。

## 重建工作集

当任务被标记为删除时，它会获得新状态和 `end` 属性等。
该任务仍在工作集中，但它不应该在那里。
有一个称为"重建"的操作，由 taskwarrior 自动运行以将任务移出工作集。
将任务移出工作集时，ID 号会改变，因为它们应该是分配给工作集中所有任务的无间隙序列。

但是工作集只是偶尔重建：在任何显示 ID 号的报告之前，但不是在以任何方式修改任务时。
原因与一般使用有关。
以下是一个典型的 taskwarrior 使用场景：

```
$ task list
...
$ task 34 done
$ task 45 modify priority:H
$ task 56 delete
$ task list
...
```

第一个命令显示包含 ID 号的报告。
接下来的三个命令使用报告中显示的 ID 号。
最后一个命令再次显示 ID 号。
显然，在中间三个命令运行时，重新对任何任务进行编号会是一个错误。
当运行最后一个命令时，会显示新的 ID 号，任何后续命令都会使用这些号。
这就是为什么只有显示 ID 号的报告才会首先执行重建。

## 配置

`gc` 配置设置可以设置为"off"来禁用重建操作。
这有在工作集中累积数据的效果，并有效地使 ID 号静态化。
这会降低几乎每个命令的速度。
禁用重建操作应该以逐个命令的方式使用，如果有的话，如下所示：

```
$ task rc.gc=off list
...
```

该设置可以永久设置，但不建议这样做。

[1] 基于 7 年多的监视使用。
